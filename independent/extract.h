// #define NDEBUG // to switch off the assertions; the speed increase is not impressive
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <assert.h>

#define ARRLEN 32
typedef unsigned int word;
typedef word bitarr[ARRLEN];

// bit array binary(bitarr[0])...binary(bitarr[ARRLEN-1])
// bits in each number are numbered from right to left, but 
// bitarr[0] contain first (not last!) bits 

#define DEGREE 1024 // degree of the field as an extension of Z_2, 2^DEGREE elements
#define CORRECTION 0b10000000000001000011 // 2^19+2^6+2^1+2^0; GCC allows binary literals
// #define CORRECTION 524355

// for testing with small values:
// #define DEGREE 16
// #define CORRECTION 0b101011 // x^16+ x^5+x^3+x^1+1

// This field is a quotient of Z_2[x] over an ideal generated by an irreducible polynomial 
// p of degree DEGREE in Z_2[x]. There is a table that contains irreducible polynomials with
// few terms in https://www.hpl.hp.com/techreports/98/HPL-98-135.pdf
// for degree 1024: 1024, 19, 6, 1 (i.e., p(x)=x^1024+x^19+x^6+x^1+1; note that the constant
// term is 1, otherwise the polynomial would be reducible.)


// If the polynomial is represented as bit array p=p[0]+p[1]+..., then elements of the 
// quotient field are arrays of length DEGREE [0..DEGREE)
// to multiply polynomial q by x we shift everything to the right, and then should
// reduce the result modulo p. This means doing nothing if q[DEGREE-1]=0; if q[DEGREE-1]=1,
// we have to add the low-degree terms. For degree 1024 this can be done by changing only the
// first word in the representation of the bit array
// Changing DEGREE, one has to change ARRLEN (so 8*size(word)*ARRLEN >= DEGREE) and
// CORRECTION; if it does not fit into one word, more changes are needed

#define SIZE 128
// size of the extracted vector in b_extract(bitarr r, bitarr a, bitarr b);
// a,b are bit vectors from source that assume to be independent and have 
// high min-entropy. A new vector r is created of length SIZE that is
// located in the first SIZE positions of r. Size should be a reasonably
// small fraction of DEGREE (as the theory recommends).
// We assume that SIZE is a multiple of 8 (so we get an integer number of bytes)

void b_set_zero (bitarr b);

void b_copy(bitarr b, bitarr c); // b<-c

void b_set_bit(bitarr b, int numbit, bool value);

bool b_get_bit(bitarr b, int numbit);

bool b_xor (bitarr x, bitarr a, bitarr b); // x <- a bitwise-xor b

bool b_or (bitarr x, bitarr a, bitarr b); // x <- a bitwise-or b

bool b_and (bitarr x, bitarr a, bitarr b); // x <- a bitwise-and b

bool b_not (bitarr x, bitarr a); // x <- bitwise-not b

int b_count(bitarr x); // count the number of ones in x

bool b_prod(bitarr x, bitarr y); // scalar product in the sense of Z_2

void b_print(bitarr b); // print b[0] b[1]... (for debugging)

void b_rshift (bitarr c, bitarr b); // c<- b shifted one bit to the right 
// it is OK if b and c are the same

// polynomial operations:

bool b_correct(bitarr b); // check that only first DEGREE bits are non-zeros

void b_multx (bitarr c, bitarr b); // c <- bx mod p; it is OK if b and c are the same

void b_mult (bitarr a, bitarr b, bitarr c);// a = b*c mod p; a should NOT be among b,c
  // but b and c can be the same array

bool b_equalp (bitarr a, bitarr b); // comparisons of first DEGREE terms. others should be zeros

// a,b are bit vectors from source that assume to be independent and have 
// high min-entropy. A new vector r is created of length SIZE that is
// located in the first SIZE positions of r. Size should be a reasonably
// small fraction of DEGREE (as the theory recommends).

void b_extract(bitarr r, bitarr a, bitarr b);
